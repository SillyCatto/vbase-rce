services:
  # Docker Socket Proxy - Security layer for Docker socket access
  # Only exposes the minimum required Docker API endpoints
  docker-socket-proxy:
    image: tecnativa/docker-socket-proxy:latest
    container_name: vbase-docker-proxy
    environment:
      # Deny everything by default, only allow what we need
      # General permissions
      - LOG=1
      - EVENTS=0
      - PING=1
      - VERSION=1
      # Container operations (required for code execution)
      - CONTAINERS=1
      - IMAGES=1
      # Allow volume mounts for sharing code files with runner containers
      - VOLUMES=1
      # Deny dangerous operations
      - AUTH=0
      - SECRETS=0
      - POST=1  # Needed for creating/starting containers
      - BUILD=0
      - COMMIT=0
      - CONFIGS=0
      - DISTRIBUTION=0
      - EXEC=0
      - GRPC=0
      - NETWORKS=0
      - NODES=0
      - PLUGINS=0
      - SERVICES=0
      - SESSION=0
      - SWARM=0
      - SYSTEM=0
      - TASKS=0
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    restart: unless-stopped
    # Limit resources
    mem_limit: 64m
    cpus: 0.25
    # tmpfs for haproxy config (needed since the proxy writes to /tmp)
    tmpfs:
      - /tmp
    # No network access needed except from rce-api
    networks:
      - docker-proxy-net

  # Main API server
  rce-api:
    build: ./api
    container_name: vbase-rce-api
    ports:
      - "8000:8000"
    volumes:
      # Named volume for sharing code files with runner containers
      # This works correctly in containerized environments (Azure, etc.)
      - vbase-code-files:/tmp/vbase-rce
    user: "0:0"  # Run initial setup as root, then drop privileges in entrypoint
    environment:
      # Connect to Docker through the proxy instead of direct socket
      - DOCKER_HOST=tcp://docker-socket-proxy:2375
      # API Key for authentication (leave empty to disable auth in dev mode)
      - VBASE_API_KEY=${VBASE_API_KEY:-}
      # Maximum concurrent code executions (default: 5)
      - MAX_CONCURRENT_JOBS=${MAX_CONCURRENT_JOBS:-5}
      # Base path for code files (must match volume mount)
      - CODE_FILES_PATH=/tmp/vbase-rce
      # Docker volume name for code files (must match volumes section with project prefix)
      - CODE_FILES_VOLUME=vbase-rce_vbase-code-files
      # User to run the app as (after volume setup)
      - APP_USER=appuser
    restart: unless-stopped
    depends_on:
      - docker-socket-proxy
      - python-runner
      - node-runner
      - c-runner
      - cpp-runner
      - java-runner
    networks:
      - docker-proxy-net

  # Runner images (built only, not run as services)
  python-runner:
    build: ./runners/python
    image: vbase-python-runner
    command: ["echo", "Python runner image built"]

  node-runner:
    build: ./runners/node
    image: vbase-node-runner
    command: ["echo", "Node runner image built"]

  c-runner:
    build: ./runners/c
    image: vbase-c-runner
    command: ["echo", "C runner image built"]

  cpp-runner:
    build: ./runners/cpp
    image: vbase-cpp-runner
    command: ["echo", "C++ runner image built"]

  java-runner:
    build: ./runners/java
    image: vbase-java-runner
    command: ["echo", "Java runner image built"]

# Network for API to communicate with Docker socket proxy
networks:
  docker-proxy-net:
    driver: bridge

# Named volume for sharing code files between API and runner containers
volumes:
  vbase-code-files:
    driver: local